  vof_advection (interfaces, i);  //对应于相变文章3数值方法部分，使用分裂输运法对该方程进行离散，把二维/三维输运问题分裂为多个一维守恒对流问题；每个方向单独求解




centered.h:241
event vof (i++,last);    //调用event vof




two-phase-generic.h:50
event tracer_advection (i++)
{
//When using smearing of the density jump, we initialise sf with the vertex-average of f. //在一些两相流模拟中，为了避免由于密度或粘度跳跃（discontinuous jump）导致的数值震荡
//我们不直接使用 f（体积分数），而是构造一个平滑的版本 sf




#ifndef sf
#if dimension <= 2
  foreach()
    sf[] = (4.*f[] + 
	    2.*(f[0,1] + f[0,-1] + f[1,0] + f[-1,0]) +
	    f[-1,-1] + f[1,-1] + f[1,1] + f[-1,1])/16.;
#else // dimension == 3
  foreach()
    sf[] = (8.*f[] +
	    4.*(f[-1] + f[1] + f[0,1] + f[0,-1] + f[0,0,1] + f[0,0,-1]) +
	    2.*(f[-1,1] + f[-1,0,1] + f[-1,0,-1] + f[-1,-1] + 
		f[0,1,1] + f[0,1,-1] + f[0,-1,1] + f[0,-1,-1] +
		f[1,1] + f[1,0,1] + f[1,-1] + f[1,0,-1]) +
	    f[1,-1,1] + f[-1,1,1] + f[-1,1,-1] + f[1,1,1] +
	    f[1,1,-1] + f[-1,-1,-1] + f[1,-1,-1] + f[-1,-1,1])/64.;
#endif
#endif // !sf




#if TREE
  sf.prolongation = refine_bilinear;
  sf.dirty = true; // boundary conditions need to be updated
#endif
}




centered.h:242




event tracer_advection (i++,last);  //调用event tracer_advection




centered.h:243




event tracer_diffusion (i++,last);   //调用event tracer_diffusion 这个事件定义在henry.h中  在每个时间步中，对伴随体积分数 f 的示踪场（如浓度、温度等）求解扩散方程




two-phase-generic.h:83 




event properties (i++)    //第二次调用event properties   根据平滑后的体积分数sf计算每个单元中的密度
{
  foreach_face() {
    double ff = (sf[] + sf[-1])/2.;
    alphav.x[] = fm.x[]/rho(ff);
    if (mu1 || mu2) {
      face vector muv = mu;
      muv.x[] = fm.x[]*mu(ff);
    }
  }
  
  foreach()
    rhov[] = cm[]*rho(sf[]);




#if TREE
  sf.prolongation = fraction_refine;
  sf.dirty = true; 边界条件需要更新
#endif
}




centered.h:250




事件属性 (i++,last)；第二次调用 在 centered.h 中执行事件属性




centered.h:323




事件 advection_term (i++,last)
{
如果 (!stokes) {
    prediction();
    mgpf = project (uf, pf, alpha, dt/2., mgpf.nrelax);
    advection ((scalar *){u}, uf, dt, (scalar *){g});
}
}
